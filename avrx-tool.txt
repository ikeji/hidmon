======================================
この説明書は、Chan さんの avrxtool32 に含まれる「avrx32.txt」を元に、hidspx
用に再編成したものです。avrsp と avrspx(hidspx) は、基本的な利用法はほぼ同
じですが、細かな違いもあります。そこで、avrsp に慣れていない方のために、avrsp
に付属する資料の一部を修正する形で作成しました(改変は許されるとありました)。

avrspやavrppに関する説明は、avrtool32に含まれる説明書をご覧ください。
======================================

■hidspxの使い方■
                                                              2008. 10. 20

 この文書は、ライタ制御プログラム使い方のみを説明しています。ハードウェア
に関しては HIDapsx ライタの製作のページを参照してください。

【動作環境と基本的な使い方】

 ライタ制御プログラムは Win32 環境で動作します。基本的にはコマンドプロンプ
ト上での操作となります。

キーボードから

  hidspx <switch> <hex file> ...

という形式で利用します。スイッチは大文字・小文字を区別しません。

常用するコマンドラインスイッチは、.ini ファイルで常用する値を指定しておくこ
ともできます。.ini ファイルは、カレントディレクトリ、実行ファイルのディレク
トリの順に検索します。コマンドラインで同じオプションを指定したときには、コ
マンドライン指定が優先されます。

 ライタ制御プログラムの特徴として、
    1. デバイス ID を読み込んでデバイス固有の情報を得て
    2. それぞれのデバイスに最適な条件で動作する
  ようになっています。

このため、ユーザ側ではデバイスタイプを指定する必要はありません。そのデバイ
ス用に作成した HEX ファイルを指定するだけです。この仕組みにより、制御プログ
ラムの実行ファイルまたはそのショートカットに HEX ファイルを D&D するだけで
一発書き込みすることも可能で、煩雑な GUI 操作の必要はありません。

【ISPケーブルでオンボード書き込み】

 AVR の書き込みでは、特別な理由がない限り、ISP 方式で行われます。ターゲッ
トの電源を OFF 状態で ISP ケーブルをターゲットボードへ接続し、完了後にター
ゲットの電源を ON にして実行します。使用可能なスイッチは次のとおりです。

  -r    デバイスとの接続チェック。
  -rp   プログラムコードの読み出し。(ファイル保存時は'> XX.hex'を利用)
  -re   EEPROMデータの読み出し。    (ファイル保存時は'> XX.eep'を利用)
  -rf   ヒューズデータ等の読み出し。

  -v    ベリファイ動作のみ実行(消去・書き込み動作はスキップ)。
  -v-   書き込み後のベリファイ動作をスキップする。

  -l[<bin>] デバイスのロック。
        値の省略時は、デフォルト値(LB1とLB2が"0"、他は"1")を設定します。

  -fl<bin> 下位ヒューズバイト書き込み。-- <bin>には1と0の2進数で指定します。
  -fh<bin> 上位ヒューズバイト書き込み。 | 0xXXという16進形式での指定も可能です。
  -fx<bin> 拡張ヒューズバイト書き込み。--
   ※ 16進数指定は、hidspxの拡張機能です。また、hidspxでは書込み後に必ず照合を行います。

  -e    チップ消去。書き込みの際は、必要に応じてチップ消去する為、
        通常は使用する必要はありません。

  -p?   使用するPort(Programmer種別)の指定。
        デフォルトは -pc1 であり、それ以外で使用する場合は、このスイッチで
        使用ポートを指定します。常用するインターフェースに合わせ .ini ファ
        イルを設定しておくと便利です。

        -pc1 … COM1 direct I/O
        -pl<n> … LPTポート(direct I/O)
            ダイレクト I/O でポートにアクセスするので、NT 系 OS ではダイレ
            クト I/O ドライバ (giveio.sys) が必要になります。

        -pv<n> … COMポート(via API)
        -pb<n>[:<bps>] … SPIブリッジ(on COM port)
            API 経由での操作であり、I/O ドライバは不要で、USB-RS232 コンバー
            タも使用できますが、USB 経由で -pv を使うと、書き込みには通常の
            100 倍程度の時間がかかります。

        -pu<n> … USBasp, USBaspx
            USBasp, USBaspxの利用を指定します。
            USBaspx ではシリアル番号を指定することで、複数の USBaspx を同時
            に区別して使うことができます。

        -ph … HIDaspx
            HIDaspxの利用を指定します。

  -c    フラッシュメモリ書き込み時、Calibration bytesをコピー。
        実行するコードにも工夫が必要です。(後半のTIPSを参照)

  -d<n> デバイスとの通信タイミング(I/Oディレイ)の指定です。
        一般的に動作クロックが 1MHz 以上ならデフォルト値(-d3)で正しく機能
        しますが、ターゲットの AVR マイコンが低速クロック (32kHz とか) で動
        作していていたり、パソコンの I/O 速度が速い場合は認識エラーやベリフ
        ァイエラーになったりします。その場合には -d100 程度までの範囲で増減
        してください。また、デバイスが高速動作しているときはディレイを減ら
        して書き込み時間を短縮できます。

        以下に、HIDaspxでATtiny2313を利用する場合の例を示します。

	  No	FUSE Low	16進	-dの値	動作周波数	備考
	   1	-fL11100100	0xE4	-d1	8MHz	14CK+65ms, -d0は16MHz以上
	   2	-fL11100010	0xE2	-d2	4MHz	14CK+65ms
	   3	-fL01100100	0x64	-d4	1MHz	工場出荷値
	   4	-fL01100010	0x62	-d5	500kHz	14CK+65ms
	   5	-fL11100110	0xE6	-d27	128kHz	14CK+65ms
	   6	-fL01100110	0x66	-d160	16kHz	110〜150では不安定です

  -w1   プログラム終了時、常にPauseする。
  -wN   Nは2以上の数字。プログラム終了時、N秒間Pauseする。
        これらはD&Dやバッチ、Make等で使う場合に使用します。

  -t<デバイス名>
        デバイスタイプを強制的に指定します。(例:-ttiny26 -t90S2313 -tmega128 など)
        何らかの理由でデバイス自動検出がうまくいかないときに試してみてくだ
        さい。

  -z    テスト信号出力。SCKに1ms周期の正極性パルスを出力します。オシロで波形
        を調べてシステムの互換性をチェックできます。(このオプションは
        HIDaspx では使えませんが、hidmon の bench コマンドで動作の確認が可
        能です。)

hidspx には、以下の機能拡張が利用できます。詳細は、avrspx の解説ページを参
照してください。

  --pause-on-start=msg       Pause on Port Open
  --pause-on-exit=msg        Pause on exit
  --list-port or -p?       List COM Port
  --list-usbasp or -pu?    List USBasp devices
  --set-serial=XXXXXX      Set USBasp serial number

■ 使用の例

例1:prog1.hexとtable.hexをプログラムメモリに、prog1.eepをEEPROMに書き込む。
  拡張子が.eep のファイルは EEPROM データ、それ以外はプログラムコードとして
  扱われます。

  >hidspx prog1.hex table.hex prog1.eep


例2:ヒューズ値は -fl -fh -fxスイッチと2進数表記を使って指定します。
  無効ビット (-) はマスクアウトされるので、0 または 1 どちらを指定してもか
  まいません。先行するゼロは省略できます。hidspx が利用している ISP モード
  では、間違えて設定すると認識不能になる(特にクロック、リセット関係)ので、
  十分な注意が必要です。

  >hidspx -FL11100011
            ~~~~~~~~
  この例では、ヒューズバイト (Low) の [4〜 2] のビット  をプログラム ("0")、
  それ以外をアンプログラム ("1") しています。


例3:プログラムメモリまたはEEPROMを読み出し、ファイルに格納。

  >hidspx -rp > file.hex
  >hidspx -re > file.eep

  読み出したデータは標準出力にインテル HEX フォーマットで出力されます。
  適切なファイル名にリダイレクトしてファイルに書き出します。なお、 1 行分の
  データがすべて 0xFF の場合にはその行は出力しませんので、無駄のない読み出
  し結果が得られます。


例4:書き込み系コマンドの連続実行。

  >hidspx -fl111100 -fh11110 -l file.hex file.eep ...

  書き込み系コマンドは、複数のオプションを同時に指定して一括処理ができます。
  実行順序はコマンドライン中の順によらす、
    Flash メモリ⇒ EEPROM ⇒ヒューズ⇒ ロックビット
  の順になります。HEX ファイルは複数個を同時に指定できますが、アドレスが重
  複している部分は、右側のファイルの内容が書き込まれます。


例5:FUSE設定の例(kumanさんが作成された資料を元にsenshuが編集)

■ Tiny2313
 クロックの種類	 		ヒューズ設定
 内蔵RC 500kHz (8分周あり)	-fL01100010 -fH11011111 -fx00000001
 内蔵RC 4MHz (8分周なし)	-fL11100010 -fH11011111 -fx00000001
 内蔵RC 1MHz (8分周あり)	-fL01100100 -fH11011111 -fx00000001
 内蔵RC 8MHz (8分周なし)	-fL11100100 -fH11011111 -fx00000001
 外部クロック信号 (8分周なし)	-fL11100000 -fH11011111 -fx00000001
 セラミック 3-8MHz		-fL11001101 -fH11011111 -fx00000001
 セラミック 8MHz〜		-fL11001111 -fH11011111 -fx00000001
 クリスタル 3-8MHz		-fL11111101 -fH11011111 -fx00000001
 クリスタル 8-20MHz		-fL11111111 -fH11011111 -fx00000001

 fL7 CKDIV8 クロック分周初期値 (1:1/1, 0:1/8)
   6 CKOUT (0:PD2にシステムクロックを出力)
   5 SUT[1] 起動時間
   4 SUT[0] 起動時間
   3 CKSEL[3] ... CKSEL[3-0] システムクロック選択
   2 CKSEL[2]
   1 CKSEL[1]
   0 CKSEL[0]

fH7 DWEN (On-Chipデバッグ 1:無効, 0:有効)
  6 EESAVE (消去でEEPROMを 1:消去, 0:保持)
  5 SPIEN (1:ISP禁止, 0:ISP許可) ※Parallel時のみ設定可能
  4 WDTON (WDT 0:常時ON, 1:通常)
  3 BODLEVEL[2]--
  2 BODLEVEL[1] |- (111=Off, 110=1.8V, 101=2.7V, 100=4.3V)
  1 BODLEVEL[0]--
  0 RSTDISBL (RESETピン 1:有効, 0:無効(PA2))

■ mega8
 クロックの種類	 		ヒューズ設定	  備考
 内蔵RC 1MHz(デフォルト)	-fL11100001 -fH11011001
 内蔵RC 2MHz			-fL11100010 -fH11011001
 内蔵RC 4MHz			-fL11100011 -fH11011001
 内蔵RC 8MHz			-fL11100100 -fH11011001
 水晶 3-8MHz		 	-fL11111111 -fH11011001
 水晶 8MHz以上		 	-fL11111111 -fH11001001
 セラミック 3-8MHz		-fL11001111 -fH11011001
 セラミック 8MHz以上		-fL11001111 -fH11001001
 外部クロック			-fL11100000 -fH11011001

 fL7 BODLEVEL (1:2.7V, 0:4.0V)
   6 BODEN (1:BOD無効, 0:BOD有効)
   5 SUT[1] 起動時間
   4 SUT[0] 起動時間
   3 CKSEL[3] ... CKSEL[3-0] システムクロック選択
   2 CKSEL[2]
   1 CKSEL[1]
   0 CKSEL[0]

fH7 RSTDISBL (RESETピン 1:有効, 0:無効(PC6))
  6 WDTON (1:WDT通常動作, 0:WDT常時ON)
  5 SPIEN (1:ISP禁止, 0:ISP許可) ※Parallel時のみ設定可能
  4 CKOPT (発振回路 1:小振幅, 0:フルスイング)
  3 EESAVE (消去でEEPROMを 1:消去, 0:保持)
  2 BOOTSZ[1] ※データシート参照
  1 BOOTSZ[0] ※データシート参照
  0 BOOTRST ※データシート参照

■ mega48
 クロックの種類	 ヒューズ設定	  備考
 内蔵RC 1MHz(デフォルト)	-fL01100010 -fH11011111 -fx00000001
 内蔵RC 8MHz(8分周なし)		-fL11100010 -fH11011111 -fx00000001
 水晶/セラミック		-fL11100111 -fH11011111 -fx00000001
 外部クロック			-fL11100000 -fH11011111 -fx00000001

 fL7 CKDIV8 クロック分周初期値 (1:1/1, 0:1/8)
   6 CKOUT (0:PB0にシステムクロックを出力)
   5 SUT[1] 起動時間
   4 SUT[0] 起動時間
   3 CKSEL[3] ... CKSEL[3-0] システムクロック選択
   2 CKSEL[2]
   1 CKSEL[1]
   0 CKSEL[0]

fH7 RSTDISBL (RESETピン 1:有効, 0:無効(PC6))
  6 DWEN (On-Chipデバッグ 1:無効, 0:有効)
  5 SPIEN (1:ISP禁止, 0:ISP許可) ※Parallel時のみ設定可能
  4 WDTON (1:WDT通常動作, 0:WDT常時ON)
  3 EESAVE (消去でEEPROMを 1:消去, 0:保持)
  2 BODLEVEL[2] --
  1 BODLEVEL[1]  |-(111=Off 110=1.8V, 101=2.7V, 100=4.3V)
  0 BODLEVEL[0] --


■ Tiny26
 クロックの種類	 	ヒューズ設定	  備考
 内蔵RC 1MHz		-fL11100001 -fH00010101
 内蔵RC 2MHz		-fL11100010 -fH00010101
 内蔵RC 4MHz		-fL11100011 -fH00010101
 内蔵RC 8MHz		-fL11100100 -fH00010101
 水晶 3M以上		-fL11111111 -fH00010101
 セラミック 3M以上	-fL11001111 -fH00010101
 外部クロック		-fL11110000 -fH00010101


【ロックビット書き込み方】

 プロテクトをかける場合は -l[<bin>] スイッチを使用します。数値を省略すると、
デフォルトでは LB2 と LB1 がプログラム ("0") されます。
 これを変更したい場合や、一緒に存在するブートロックビットをプログラムした
い場合は、ロックバイトの値を明示的に指定する必要があります。詳しくは各デバ
イスのデータシートを参照してください。


【COMポートISPケーブルでの通信】

 COM ポート接続のライタ (ISP ケーブル) では、ホスト PC と AVR の間で通信す
ることができます。ハードウェアデバッグや実際の運用などに役立つでしょう。
 プログラムを書き込んだ後、ホスト PC で通信ソフトを起動すると、ER 信号が"
H"になり、AVR のリセットが解除され、AVR のプログラムが走ります。この際、MISO
に当たるピンを出力に、MOSI に当たるピンを入力に設定することにより、ソフトウ
ェア UART でホスト PC と通信することができるのです。
この場合は、COM ポート直結なので、シリアルデータの論理が逆になります(L=1、H=0)。
ソフトウェア UART については別アーカイブのサンプルコードを参照してみてくだ
さい。(このアーカイブには含まれません)


【エラーメッセージと原因・対策】

  書き込みツールを使用する際に、エラーを出して停止する場合があります。
次にそれぞれのエラーメッセージとその原因と対策を示します。


<ファイル名> : File access failure
----------------------------------
そのファイルが開けない。


<ファイル名> (<行番号>) : Hex format error
------------------------------------------
HEXファイルにエラーがある。または、Intel HEXまたはMotrola Sファイルではない。


Writing...Time out at AAAA
--------------------------
書き込み中にポーリングタイムアウトが発生した。


Verifying...Failed at AAAA:WW->RR
--------------------------------
読み出したデータとファイルのデータが一致しない。


Unknown device (<h>-<h>-<h>)
----------------------------
デバイスIDが無効。3つの値は、読み出されたデバイスID。
考えられる原因として、デバイスが正常に動作していない、未サポートのデバイス、
通信エラー、または ISP 動作ができない状態になっているなどです。

Locked device or Synchronization failed.
----------------------------------------
ISP 動作時に検出されるエラーで、デバイスがロックされている、または通信エラー
が原因でこのメッセージが出る場合もあります。ロックされたデバイスには書き込
めないので、-e コマンドで全消去する必要があります。


No LPT<n>(0xXXX) port.
No COM<n>(0xXXX) port.
COM<n> could not be opend.
Invalid Port#.
--------------------------
指定されたポートが存在しない、またはそのポートクラスに対して無効な番号など。
ダイレクトI/Oの場合、ポート番号とI/Oアドレスの対応は、定数テーブルで決め打ち
しています(hwctrl.h参照)。


I/O driver initialization failed.
---------------------------------
WindowsNT/2k/XP の環境ではダイレクト I/O ドライバ (giveio.sys) が必要ですが、
これが利用可能になっていない。


【このアーカイブの扱いについて】

 このアーカイブに含まれるファイルはすべてフリーソフトとします。転載・改変・
再配布については特に制限を設けていませんが、フリーソフトを扱う上でのルール
はお守りください。
 AVR ライタ関連について、次の web サイトでもサポートを行っていますので、ご
利用ください。

http://elm-chan.org/


【更新履歴】

  1999.10.3	初公開(DOS版)
  ------------------------------------------------------------------------
  2004.5.4	ISPライタのWin32版公開。
  2004.9.1	mega165に対応。mega8のパラメータ修正。
  2004.11.11	パラレルライタのWin32版公開。mega325/3250/645/6450に対応。
  2005.2.1	mega406に対応(AVRPP)。
  2005.2.14	PWM2/3に対応(AVRSP/AVRPP)。
  2005.2.15	tiny25/45/85に対応(AVRSP/AVRPP)。
  2005.3.13	mega640/1280/1281/2560/2561に対応(AVRSP/AVRPP)。
  2005.4.24	API経由COMポートとSPIブリッジに対応(AVRSP)。
  2005.5.20	SPIブリッジでの速度を改善(AVRSP)。
  2005.8.10	tiny24/44/84に対応(AVRSP/AVRPP)。
  2006.1.30	CAN32/64に対応(AVRSP/AVRPP)。-w<num> (AVRSP)。-q (AVRPP)。
  2006.5.14	mega644に対応(AVRSP/AVRPP)。tiny2313のcal数を更新。
  2007.3.18     mega164P/324P/644P, tiny261/461/861に対応(AVRSP/AVRPP)。
  2007.6.21     mega640/1280/1281/2560/2561のパラメータを修正(AVRSP/AVRPP)。
  2007.8.5      mega48P/88P/168P/328Pに対応(AVRSP/AVRPP)。
  2007.12.16    SPIブリッジでの速度を改善(要SPIブリッジR4以降)。


---------------------------------------------------------------------------------
[TIPS]

■AVRライタ制御プログラム TIPS

 このファイルには AVR ライタ製作を通して得られたノウハウや注意点などを記し
ておきます。実際に制御プログラムを書かれたりライタを改良する際の手助けとな
れば幸いです。


●タイミング生成

 ライタ制御のタイミングを得るために、ms 単位ではシステム BIOS のディレイ機
能を μs 単位では MPU 速度依存の少ない I/O リードを使用しています。


●デバイスの自動認識(ISPモード)

 AT90S1200 とそれ以外のデバイスでは、最初のコマンド同期シーケンスの手順が
異なります。
 そこで、まず 1200 方式(RESET パルス)で同期シーケンスを実行し、次にエコー
バック方式を試みるようにしています。有効なデバイス ID が読み出せるまで「同
期→ ID 読み出し」を3回までリトライしますが、最初の2回は 1200 方式、3回
目はエコーバックで同期シーケンスを実行します。これにより、ISP モードにおい
ても全てのデバイスで自動認識を実現しています。


●0xFFスキップ

 書き込み時間を短縮するため、書き込む必要の無いバイト (またはページ)、たと
えばロードされなかった領域やプログラムメモリで値が 0xFF、へのプログラム動作
はスキップしています。


●書き込み完了待ち(ISPモード)

 ISP モードでは、デバイス内でのバイト書き込みの完了を待つのにポーリングを
使用しています。このため、書き込み時間は個々のデバイスの能力と電源電圧に依
存することになります。
 しかし、S1200 はデータシートに記されているにも関わらずポーリングがうまく
機能しないようなので、これについては 12ms のタイマーで次のバイトに移るよう
にしています(5V では 4ms で OK だが、3V までカバーするにはこの程度必要)。
 また、ページモード書き込みのデバイスでは、ページ書き込みの終了待ちをタイ
マーとしています。


●キャリブレーションバイト(CAL値)について

 オシレータ内蔵デバイスの多くは、OSCCAL レジスタに CAL 値を書き込んで発振
周波数の製造上のバラツキを補正をするようになっています。この値はプログラマ
で読み出すことができます。avrps/avrspx(hidspx) の場合、ヒューズ読み出しでそ
のデバイスの CAL 値が確認できます。CAL 値は、1 または 4個の 10 進数で表示さ
れ、4個ある場合は、左から順に 1MHz 用、2MHz 用、4MHz 用、8MHz 用です。

 特に OSCCAL レジスタの初期値が 0 になる古いデバイスは、内蔵オシレータを使
う場合、必ず初期化動作が必要になります。デバイス毎に固有な CAL 値は、何らか
の手段でプログラム中に埋め込む必要があります。多数のデバイスに書き込む場合
は、ソースファイルに CAL 値を直接コーディングすることが難しいので、プログラ
マ側での対応も必要になります。

 プログラム書き込み時には -c スイッチを指定すると、CAL 値をフラッシュメモ
リの最後バイトにセットします。4個ある場合は、最終バイトから順に 1MHz 用...
8MHz 用の准で配置されます。プログラムは初期化時にそれを読み出して設定してや
れば OK です。

example:
    c = pgm_read_byte(FLASHEND - n); // written by -c switch
    if(c != 0xFF) OSCCAL = c;


●ISP動作での通信速度

 -d スイッチは、ISP モードでのデバイスとの通信速度を変更します。ISP 動作で
可能な通信速度はデバイスの動作クロックに依存するので、通信速度調整のためタ
イミングディレイを挿入しています。低速クロック時にデバイスを認識できないと
きは、このオプションで速度を調整してみてください。

●RSTDISBLヒューズ

 いくつかのデバイスでは RESET ピンをポートとして使う設定がありますが、その
状態では ISP モードが動作しません。ISP モードを利用する場合には RSTDISBL ヒ
ューズを誤ってプログラムしないよう注意が必要です。また、RSTDISBL ヒューズを
プログラムされている場合は、高電圧のパラレル (HVS) ライタで -q スイッチが必
要になることがあります。


●JTAGENヒューズ

 最近発表されたデバイスは JTAG 機能を持っているものが増えています。デフォ
ルトでは JTAG が有効になっていて、JTAG 機能と重複するピンが I/O ポートとし
て使えません。これを通常の I/O として使えるようにするには、プログラム実行時
に MCU 制御レジスタの JTD ビットを立てる必要があります。または、JTAGEN ヒュー
ズをアンプログラム("1")します。


●各種パラレルアダプタの自動認識

 avrsp/avrspx(hidspx) は複数のプログラミングアダプタに対応するため、アダプ
タのタイプを自動認識しています。次の順にパラレルポートの接続をチェックして、
最初にマッチした組み合わせでアダプタタイプを決定します。

1. D5-ACK        Altera ByteBlasterMV
2. D7-PE         AVRX
3. D6-BUSY-PE    Xilinx JTAG
4. D6-PE         Lattice ISP
5. D0-PE         STK200 dongle

