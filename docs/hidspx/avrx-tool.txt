======================================
この説明書は、Chan さんの avrxtool32 に含まれる「avrx32.txt」を元に、hidspx
用に再編成したものです。avrsp と avrspx(hidspx) は、基本的な利用法はほぼ同
じですが、細かな違いもあります。そこで、avrsp に慣れていない方のために、avrsp
に付属する資料の一部を hidspx に適合するように、内容を修正する形で作成しま
した (改変は許されるとありました)。

なお、hidspx.exe は avrspx.exe とリネームすれば、最新の avrspx.exe として利
用可能です。

avrspやavrppに関する説明は、avrtool32に含まれる説明書をご覧ください。
======================================

■hidspxの使い方■
                                                              2008. 11. 05
                                                              2010.  8. 04

　この文書は、ライタ制御プログラム使い方のみを説明しています。ハードウェアに関
しては HIDapsx ライタの製作のページを参照してください。

【動作環境と基本的な使い方】

　ライタ制御プログラムは Win32 環境で動作します。基本的にはコマンドプロンプト上
での操作となります。

キーボードから

  hidspx <switch> <hex file> ...

という形式で利用します。<switch>は大文字・小文字を区別しません。

コマンドラインから常に指定するスイッチは、.ini ファイルで常用する値を指定してお
くこともできます。.ini ファイルは、カレントディレクトリ、実行ファイルのディレク
トリの順に検索します。つまり、そのプロジェクトで利用する値を個々に設定可能にな
っています。また、コマンドラインで同じオプションを指定したときには、コマンドラ
イン指定を優先しますので、一時的に値を変更する場合でも ini ファイルを編集する必
要はありません。

 ライタ制御プログラムの特徴として、
    1. デバイス ID を読み込んでデバイス固有の情報を得て
    2. それぞれのデバイスに最適な条件で動作する
  ようになっています。

このため、ユーザ側ではデバイスタイプを指定する必要はありません。そのデバイス用
に作成した HEX ファイルを指定するだけで書込みが可能です。この仕組みにより、制御
プログラムの実行ファイルまたはそのショートカットに HEX ファイルを D&D するだけ
で一発書き込みすることも可能になっており、その他のツールにあるような煩雑な GUI
操作の必要ありません。

【ISPケーブルでオンボード書き込み】

　AVR の書き込みでは、特別な理由がない限り、ISP 方式で行われます。ターゲットの
電源を OFF 状態で ISP ケーブルをターゲットボードへ接続し、完了後にターゲットの
電源を ON にして実行します。使用可能なスイッチは次のとおりです。

  -r    デバイスとの接続チェック。
        ライタの初期化やターゲットマイコンのRESETにも利用可能。
  -rf   ヒューズデータ等の読み出し。

  -rp   プログラムコードの読み出し。(ファイル保存時は'> XX.hex'を利用)
  -re   EEPROMデータの読み出し。    (ファイル保存時は'> XX.eep'を利用)

  オプション無しの <hex file> 指定
        指定した <hex file> を書き込みます。

  -v    ベリファイのみ実行(消去・書き込み動作はスキップ)。
  -v-   書込みのみ実行（書き込み後のベリファイ動作をスキップ）。

  -l[<bin>] デバイスのロック。
        値の省略時は、「LB1とLB2を"0"、他のビットは"1"」に設定します。

	■ メモリロックビット(共通)の意味
	モード	LB1	LB2	保護の種類
	1	1	1	メモリロック機能は無効（チップ消去後の通常状態）
	2	0	1	フラッシュとEEPROM の追加プログラミングを無効にする
	3	0	0	モード2に加え、ベリファイも禁止する

	※ AVRマイコンによっては、上位の7〜2ビットにも機能割り当てがあります。
	このビットを有効にすると書込みや照合が出来なくなりますので、最終的に
	保護する段階で、メモリロックを有効にしてください。

  -fl<bin> 下位ヒューズバイト書き込み。-- <bin>には1と0の2進数で指定します。
  -fh<bin> 上位ヒューズバイト書き込み。 | 0xXXという16進形式での指定も可能です。
  -fx<bin> 拡張ヒューズバイト書き込み。--
   ※ 16進数での指定はhidspxの拡張機能です。また、hidspxでは書込み後に照合を行います。

  -e    チップ消去。書き込みの際は、必要に応じてチップ消去する為、
        通常は使用する必要はありません。

  -p?   使用するPort(Programmer種別)の指定。
        デフォルトは -pc1 であり、それ以外で使用する場合は、このスイッチで
        使用するポートを指定します。なお、複数の Port を指定した場合には、
        最後に指定したもので動作しますので、常用するインターフェースに合わ
        せ .ini ファイルを設定しておくと便利です。

        -pc1 … COM1 direct I/O

        -pl<n> … LPTポート(direct I/O)
            ダイレクト I/O でポートにアクセスするので、NT 系 OS ではダイレ
            クト I/O ドライバ (giveio.sys) が必要になります。

        -pv<n> … COMポート(APIのみを使用)

        -pb<n>[:<bps>] … SPIブリッジ(on COM port)
            API 経由での操作であり、I/O ドライバは不要で、USB-RS232 コンバー
            タも使用できますが、USB 経由で -pv を使うと、書き込みには通常の
            100 倍程度の時間がかかります。

        -pu<n> … USBasp, USBaspx
            USBasp, USBaspxの利用を指定します。
            USBaspx ではシリアル番号を指定することで、複数の USBaspx を区別
            して使うことができます。
            -pu?を指定すると、接続しているUSBaspxの一覧を表示します。

        -ph<n> … HIDaspx
            HIDaspxの利用を指定します。
            HIDaspx ではシリアル番号を指定することで、複数の HIDaspx を
            区別して使うことができます。
            -ph?を指定すると、接続しているHIDaspxの一覧を表示します。

  -c    フラッシュメモリ書き込み時、Calibration bytes を FLASH メモリの最終
        アドレスにコピー。実行するコードにも工夫が必要です。(後半の TIPS を参照)

  -d<n> デバイスとの通信タイミング(I/Oディレイ)の指定です。
        一般的に動作クロックが 1MHz 以上ならデフォルト値 (-d3) で正しく機能しま
        すが、ターゲットの AVR マイコンが低速クロック (32kHz とか) で動作してい
        ていたり、パソコンの I/O 速度が速い場合は認識エラーやベリファイエラーに
        なったりします。その場合には -d100 程度までの範囲で増減してください。デ
        バイスが高速動作している時は、ディレイの値を減らし書き込み時間を短縮で
        きます。

        以下に、HIDaspxでATtiny2313を利用する場合の例を示します。

	  No	FUSE Low	16進	-dの値	動作周波数	備考
	   1	-fL11100100	0xE4	-d1	8MHz	14CK+65ms, -d0は16MHz以上
	   2	-fL11100010	0xE2	-d2	4MHz	14CK+65ms
	   3	-fL01100100	0x64	-d4	1MHz	工場出荷値
	   4	-fL01100010	0x62	-d5	500kHz	14CK+65ms
	   5	-fL11100110	0xE6	-d27	128kHz	14CK+65ms
	   6	-fL01100110	0x66	-d160	16kHz	110〜150では不安定です

  -w1   プログラム終了時、常にPauseする。（Enterキーの押下を待つ）
  -wN   Nは2以上の数字。プログラム終了時、N秒間Pauseする。
        これらは、hidspx の実行結果を確認する為に利用します。HEXファイルをhidspxに
　　　　D&D して書き込む、あるいはバッチ, Make 等で使う場合に効果的に使用できます。

  -t<デバイス名>
        デバイスタイプを強制的に指定します。(例:-ttiny26 -t90S2313 -tmega128 な
        ど) 旧タイプの AVR マイコンなどでデバイス自動検出がうまくいかないときに
        試してみてください。

  -z    テスト信号出力。SCKに1ms周期の正極性パルスを出力します。オシロで波形
        を調べてシステムの互換性をチェックできます。(このオプションは HIDaspx
        では使えませんが、hidmon の bench コマンドで接続テストが可能です。)

hidspx では、以下の機能拡張が利用できます。詳細は、avrspx の解説ページを参
照してください。

  --pause-on-start=msg     Pause on Port Open
  --pause-on-exit=msg      Pause on exit
  --list-port or -p?       List COM Port
  --list-usbasp or -pu?    List USBasp devices
  --set-serial=XXXXXX      Set USBasp serial number



■Flash/EEPROM/Fuse混合hexファイル

　最近の avr-gcc では、従来、別々に扱っていた Flash/EEPROM/Fuse ファイルを一つ
の hex ファイルに納めることができます。この機能を使えば、プログラム配布時などに
重宝します。AVRSP(hidspx) は、この混合 hex ファイルに対応しました。混合 hex フ
ァイルは、次のようにして生成します。

　まず、EEPROM データや FUSE データをソースファイル中に記述します。EEPROM デー
タの記述は既に一般化しているので、FUSE 値はソースファイル中で次のように指定しま
す。

#include <avr/io.h>		/* これによりfuse.hがインクルードされる */

FUSES = {0xE1, 0xDD, 0x01};	/* {Low, High, Ext} */

　次に、EEPROM/Fuse データを hex ファイルに出力するため、Makefile 中の記述を次
のように設定します。

    $(OBJCOPY) -j .text -j .data -j .eeprom -j .fuse -O ihex $< $@
                                 ~~~~~~~~~~ ~~~~~~~~
これで、混合 hex ファイルが生成されます。AVRSP(hidspx) では、指定された hex フ
ァイルを読み出し、個々のバイトのオフセットアドレスを元に、次に示す領域のどれに
属するかで判断しています。

0x00000000..0x0003FFFF : プログラムメモリ(256K)
0x00810000..0x00810FFF : EEPROM(4K)
0x00820000..0x00820002 : ヒューズ(3バイト)

なお、従来の EEPROM ファイル (拡張子が.eep) は 0x00810000 のオフセットを加算し
て読み込むので、従来通りの利用で EEPROM データを扱うことができます。



■ 使用の例

例1:prog1.hexとtable.hexをプログラムメモリに、prog1.eepをEEPROMに書き込む。
  拡張子が.eep のファイルは EEPROM データ、それ以外はプログラムコードとして
  扱われます。

  >hidspx prog1.hex table.hex prog1.eep


例2:ヒューズ値は -fl -fh -fxスイッチと2進数表記を使って指定します。
  無効ビット (-) はマスクアウトされるので、0 または 1 どちらを指定してもか
  まいません。先行するゼロは省略できます。hidspx が利用している ISP モード
  では、間違えて設定すると認識不能になる(特にクロック、リセット関係)ので、
  十分な注意が必要です。

  >hidspx -FL11100011
            ~~~~~~~~
  この例では、ヒューズバイト (Low) の [4〜 2] のビット  をプログラム ("0")、
  それ以外をアンプログラム ("1") しています。


例3:プログラムメモリまたはEEPROMを読み出し、ファイルに格納。

  >hidspx -rp > file.hex
  >hidspx -re > file.eep

  読み出したデータは標準出力にインテル HEX フォーマットで出力されます。適切
  なファイル名にリダイレクト（> file 名）してファイルに書き出します。なお、
  1 行分のデータがすべて 0xFF の場合はその行は出力しません。この機能により、
  無駄のない読み出し結果が得られます。


例4:書き込み系コマンドの連続実行。

  >hidspx -fl111100 -fh11110 -l file.hex file.eep ...

  書き込み系コマンドは、複数のオプションを同時に指定して一括処理ができます。

  実行順序はコマンドライン中の順に関係なく、

    Flash メモリ⇒ EEPROM ⇒ヒューズ⇒ ロックビット

  の順になります。HEX ファイルは複数個を同時に指定できます（*.hex も可能）
  が、アドレスが重複している部分は、コマンド行の後方（右側）のファイルの内
  容を書き込みます。


例5:FUSE設定の例(kumanさんが作成された資料を元にsenshuが編集)

　以下の例では、設定項目を「コピー＆ペースト」を可能にするため、無関係なビ
ット'-'についても、0 または 1 にセットしています。
　また、「ヒューズビットの、L と H をともに書き換える時は、以下の様に指定を
行ない、同時に書き込む」ようにしてください。正しい設定値と H.L の同時書込み
を実行すれば、FUSE 設定ミスを最小限にできます。

　-fLxxxxxxxx -fHxxxxxxxxx

■ Tiny2313
 クロックの種類	 		ヒューズ設定
 内蔵RC 500kHz (8分周あり)	-fL01100010 -fH11011111 -fX00000001
 内蔵RC 4MHz (8分周なし)	-fL11100010 -fH11011111 -fX00000001
 内蔵RC 1MHz (8分周あり)	-fL01100100 -fH11011111 -fX00000001
 内蔵RC 8MHz (8分周なし)	-fL11100100 -fH11011111 -fX00000001
 外部クロック信号 (8分周なし)	-fL11100000 -fH11011111 -fX00000001
 セラミック 3-8MHz		-fL11001101 -fH11011111 -fX00000001
 セラミック 8MHz〜		-fL11001111 -fH11011111 -fX00000001
 クリスタル 3-8MHz		-fL11111101 -fH11011111 -fX00000001
 クリスタル 8-20MHz		-fL11111111 -fH11011111 -fX00000001

 fL7 CKDIV8 クロック分周初期値 (1:1/1, 0:1/8)
   6 CKOUT (0:PD2にシステムクロックを出力)
   5 SUT[1] 起動時間
   4 SUT[0] 起動時間
   3 CKSEL[3] ... CKSEL[3-0] システムクロック選択
   2 CKSEL[2]  |
   1 CKSEL[1]  |
   0 CKSEL[0] -

fH7 DWEN (On-Chipデバッグ 1:無効, 0:有効)
  6 EESAVE (消去でEEPROMを 1:消去, 0:保持)
  5 SPIEN (1:ISP禁止, 0:ISP許可) ※Parallel時のみ設定可能
  4 WDTON (WDT 0:常時ON, 1:通常)
  3 BODLEVEL[2]-
  2 BODLEVEL[1] |- (111=Off, 110=1.8V, 101=2.7V, 100=4.3V)
  1 BODLEVEL[0]-
  0 RSTDISBL (RESETピン 1:有効, 0:無効(PA2))

■ mega8
 クロックの種類	 		ヒューズ設定
 内蔵RC 1MHz(デフォルト)	-fL11100001 -fH11011001
 内蔵RC 2MHz			-fL11100010 -fH11011001
 内蔵RC 4MHz			-fL11100011 -fH11011001
 内蔵RC 8MHz			-fL11100100 -fH11011001
 水晶 3-8MHz		 	-fL11111111 -fH11011001
 水晶 8MHz以上		 	-fL11111111 -fH11001001
 セラミック 3-8MHz		-fL11001111 -fH11011001
 セラミック 8MHz以上		-fL11001111 -fH11001001
 外部クロック			-fL11100000 -fH11011001

 fL7 BODLEVEL (1:2.7V, 0:4.0V)
   6 BODEN (1:BOD無効, 0:BOD有効)
   5 SUT[1] 起動時間
   4 SUT[0] 起動時間
   3 CKSEL[3] ... CKSEL[3-0] システムクロック選択
   2 CKSEL[2]  |
   1 CKSEL[1]  |
   0 CKSEL[0] -

fH7 RSTDISBL (RESETピン 1:有効, 0:無効(PC6))
  6 WDTON (1:WDT通常動作, 0:WDT常時ON)
  5 SPIEN (1:ISP禁止, 0:ISP許可) ※Parallel時のみ設定可能
  4 CKOPT (発振回路 1:小振幅, 0:フルスイング)
  3 EESAVE (消去でEEPROMを 1:消去, 0:保持)
  2 BOOTSZ[1] ※データシート参照
  1 BOOTSZ[0] ※データシート参照
  0 BOOTRST ※データシート参照

■ mega48
 クロックの種類	 		ヒューズ設定
 内蔵RC 1MHz(デフォルト)	-fL01100010 -fH11011111 -fX00000001
 内蔵RC 8MHz(8分周なし)		-fL11100010 -fH11011111 -fX00000001
 水晶/セラミック		-fL11100111 -fH11011111 -fX00000001
 外部クロック			-fL11100000 -fH11011111 -fX00000001

 fL7 CKDIV8 クロック分周初期値 (1:1/1, 0:1/8)
   6 CKOUT (0:PB0にシステムクロックを出力)
   5 SUT[1] 起動時間
   4 SUT[0] 起動時間
   3 CKSEL[3] ... CKSEL[3-0] システムクロック選択
   2 CKSEL[2]
   1 CKSEL[1]
   0 CKSEL[0]

fH7 RSTDISBL (RESETピン 1:有効, 0:無効(PC6))
  6 DWEN (On-Chipデバッグ 1:無効, 0:有効)
  5 SPIEN (1:ISP禁止, 0:ISP許可) ※Parallel時のみ設定可能
  4 WDTON (1:WDT通常動作, 0:WDT常時ON)
  3 EESAVE (消去でEEPROMを 1:消去, 0:保持)
  2 BODLEVEL[2] -
  1 BODLEVEL[1]  |-(111=Off 110=1.8V, 101=2.7V, 100=4.3V)
  0 BODLEVEL[0] -


■ Tiny26
 クロックの種類	 	ヒューズ設定
 内蔵RC 1MHz		-fL11100001 -fH00010101
 内蔵RC 2MHz		-fL11100010 -fH00010101
 内蔵RC 4MHz		-fL11100011 -fH00010101
 内蔵RC 8MHz		-fL11100100 -fH00010101
 水晶 3M以上		-fL11111111 -fH00010101
 セラミック 3M以上	-fL11001111 -fH00010101
 外部クロック		-fL11110000 -fH00010101


【ロックビット書き込み】

　メモリをプロテクトする場合は -l[<bin>] スイッチを使用します。数値を省略す
ると、デフォルトでは mode 3 （LB2 と LB1 を ("0")）にプログラムします。
LB2,LB1 以外のブートロックビットをプログラムしたい場合には、ロックバイトの
値を明示的に指定します。詳しくは各デバイスのデータシートを参照してください。

 ※ 設定したロックビットを「-e」でデバイス消去を行うことで、mode0 に戻すこ
    とができます。

【COMポートISPケーブルでの通信】

　COM ポート接続のライタ (ISP ケーブル) では、ホスト PC と AVR の間で通信す
ることができます。ハードウェアデバッグや実際の運用などに役立つでしょう。
　プログラムを書き込んだ後、ホスト PC で通信ソフトを起動すると、ER 信号が
"H"になり、AVR のリセットが解除され、AVR のプログラムが走ります。この際、MISO
に当たるピンを出力に、MOSI に当たるピンを入力に設定することにより、ソフトウ
ェア UART でホスト PC と通信することができるのです。
この場合は、COM ポート直結なので、シリアルデータの論理が逆になります (L=1、
H=0)。ソフトウェア UART については別アーカイブのサンプルコードを参照してみ
てください。(このアーカイブには含まれません)


【エラーメッセージと原因・対策】

  書き込みツールを使用する際に、エラーを出して停止する場合があります。
次にそれぞれのエラーメッセージとその原因と対策を示します。


★ <ファイル名> : File access failure
   ----------------------------------
[原因]そのファイルが開けない。
[対策]正しいファイル名を指定する。


★ <ファイル名> (<行番号>) : Hex format error
   ------------------------------------------
[原因]HEXファイルにエラーがある。または、Intel HEXまたはMotrola Sファイルではない。
[対策]正しいファイル名を指定する。

★ Writing...Time out at AAAA
   --------------------------
[原因]書き込み中にポーリングタイムアウトが発生した。
[対策]機器の接続を見直し、再試行する。


★ Verifying...Failed at AAAA:WW->RR
   --------------------------------
[原因]読み出したデータとHEXファイルの内容が一致しない。
[対策]「-dオプション指定」を見直し、大き目の値を指定し書き込む。


★ Unknown device (<h>-<h>-<h>)
   ----------------------------
[原因]
読み出して得られたデバイス ID が無効。表示される 3 つの値は、読み出したデバ
イス ID。デバイスが正常に動作していない（発振していない）、未サポートのデバ
イス、通信エラーの発生、ISP 動作ができない状態（ハードウェアの不適合）にな
っていることが考えられる。
[対策]
不安定な動作をするハードウェアや、「-d オプションの値が不適切」な場合に発生
することが多い。

★ Locked device or Synchronization failed.
   ----------------------------------------
[原因]
ISP 動作時に検出されるエラーです。デバイスがロック状態にある、あるいは通信
エラーが発生した。
[対策]
メモリがロックされているデバイスには書き込めませんが、-e コマンドで消去する
ことでロックを解除できます。


★
   No LPT<n>(0xXXX) port.
   No COM<n>(0xXXX) port.
   COM<n> could not be opend.
   Invalid Port#.
   --------------------------

[原因]
指定されたポートが存在しない、またはそのポートクラスに対して無効な番号を指
定したなど。ダイレクト I/O の場合、ポート番号と I/O アドレスの対応は、定数
テーブルで決め打ちしています (hwctrl.h 参照)。
[対策]
正しい値を指定します。

★ I/O driver initialization failed.
   ---------------------------------
[原因]
WindowsNT/2k/XP 環境ではダイレクト I/O ドライバ (giveio.sys) が必要ですが、
これが利用可能になっていない。
[対策]
I/Oドライバをインストールします。

【このアーカイブの扱いについて】

　このアーカイブに含まれるファイルはすべてフリーソフトとします。転載・改変・再
配布については特に制限を設けていませんが、フリーソフトを扱う上でのルールはお守
りください。
　AVR ライタ関連について、次の web サイトでもサポートを行っていますので、ご利用
ください。

http://elm-chan.org/


【更新履歴】

  1999.10.3	初公開(DOS版)
  ------------------------------------------------------------------------
  2004.5.4	ISPライタのWin32版公開。
  2004.9.1	mega165に対応。mega8のパラメータ修正。
  2004.11.11	パラレルライタのWin32版公開。mega325/3250/645/6450に対応。
  2005.2.1	mega406に対応(AVRPP)。
  2005.2.14	PWM2/3に対応(AVRSP/AVRPP)。
  2005.2.15	tiny25/45/85に対応(AVRSP/AVRPP)。
  2005.3.13	mega640/1280/1281/2560/2561に対応(AVRSP/AVRPP)。
  2005.4.24	API経由COMポートとSPIブリッジに対応(AVRSP)。
  2005.5.20	SPIブリッジでの速度を改善(AVRSP)。
  2005.8.10	tiny24/44/84に対応(AVRSP/AVRPP)。
  2006.1.30	CAN32/64に対応(AVRSP/AVRPP)。-w<num> (AVRSP)。-q (AVRPP)。
  2006.5.14	mega644に対応(AVRSP/AVRPP)。tiny2313のcal数を更新。
  2007.3.18     mega164P/324P/644P, tiny261/461/861に対応(AVRSP/AVRPP)。
  2007.6.21     mega640/1280/1281/2560/2561のパラメータを修正(AVRSP/AVRPP)。
  2007.8.5      mega48P/88P/168P/328Pに対応(AVRSP/AVRPP)。
  2007.12.16    SPIブリッジでの速度を改善(要SPIブリッジR4以降)。
  2008.12.7     mega325P/3250P/324PA, PWM216,316に対応(AVRSP/AVRPP)。
  2010.7.21     Flash/EEPROM/Fuse混合hexファイルに対応(AVRSP/AVRPP)。


---------------------------------------------------------------------------------
[TIPS]

■AVRライタ制御プログラム TIPS

　このファイルには AVR ライタ製作を通して得られたノウハウや注意点などを記してお
きます。実際に制御プログラムを書かれたりライタを改良する際の手助けとなれば幸い
です。


●タイミング生成

　ライタ制御のタイミングを得るために、ms 単位ではシステム BIOS のディレイ機能を
μs 単位では MPU 速度依存の少ない I/O リードを使用しています。


●デバイスの自動認識(ISPモード)

　AT90S1200 とそれ以外のデバイスでは、最初のコマンド同期シーケンスの手順が異な
ります。
　そこで、まず 1200 方式 (RESET パルス) で同期シーケンスを実行し、次にエコーバ
ック方式を試みるようにしています。有効なデバイス ID が読み出せるまで「同期→ ID
読み出し」を 3 回までリトライしますが、最初の 2 回は 1200 方式、3 回目はエコー
バックで同期シーケンスを実行します。これにより、ISP モードにおいても全てのデバ
イスで自動認識を実現しています。


●0xFFスキップ

　書き込み時間を短縮するため、書き込む必要の無いバイト (またはページ)、たとえば
ロードされなかった領域やプログラムメモリで値が 0xFF、へのプログラム動作はスキッ
プしています。


●書き込み完了待ち(ISPモード)

　ISP モードでは、デバイス内でのバイト書き込みの完了を待つのにポーリングを使用
しています。このため、書き込み時間は個々のデバイスの能力と電源電圧に依存するこ
とになります。
　しかし、S1200 はデータシートに記されているにも関わらずポーリングがうまく機能
しないようなので、これについては 12ms のタイマーで次のバイトに移るようにしてい
ます (5V では 4ms で OK だが、3V までカバーするにはこの程度必要)。また、ページ
モード書き込みのデバイスでは、ページ書き込みの終了待ちをタイマーとしています。


●キャリブレーションバイト(CAL値)について

　オシレータ内蔵デバイスの多くは、OSCCAL レジスタに CAL 値を書き込んで発振周波
数の製造上のバラツキを補正をするようになっています。この値はプログラマで読み出
すことができます。

avrps/avrspx(hidspx) の場合、「-rf コマンド」にてヒューズを読み出ス事によりその
デバイスの CAL 値が確認できます。CAL 値は、1 または 4個の 10 進数で表示され、4
個ある場合は、左から順に 1MHz 用、2MHz 用、4MHz 用、8MHz 用です。

　特に OSCCAL レジスタの初期値が 0 になる古いデバイスは、内蔵オシレータを使う場
合、必ず初期化動作が必要になります。デバイス毎に固有な CAL 値は、何らかの手段で
プログラム中に埋め込む必要があります。多数のデバイスに書き込む場合は、ソースフ
ァイルに CAL 値を直接コーディングすることが難しいので、プログラマ側での対応も必
要になります。

　プログラム書き込み時には -c スイッチを指定すると、CAL 値をフラッシュメモリの
最後バイトにセットします。4個ある場合は、最終バイトから順に 1MHz 用〜 8MHz 用の
順で配置されます。プログラムは初期化時にその値を読み出して設定を行います。

example:
    c = pgm_read_byte(FLASHEND - n); // read calibration byte written by -c sw
    if(c != 0xFF) OSCCAL = c;


●ISP動作での通信速度

　-d スイッチは、ISP モードでのデバイスとの通信速度を変更します。ISP 動作で可能
な通信速度はデバイスの動作クロックに依存するので、通信速度調整のためタイミング
ディレイを挿入しています。低速クロック時にデバイスを認識できないときは、このオ
プションで速度を調整してみてください。

●RSTDISBLヒューズ

　いくつかのデバイスでは RESET ピンをポートとして使う設定がありますが、その状態
では ISP モードが動作しません。ISP モードを利用する場合には RSTDISBL ヒューズを
誤ってプログラムしないよう注意が必要です。また、RSTDISBL ヒューズをプログラムさ
れている場合は、高電圧のパラレル (HVS) ライタで -q スイッチが必要になることがあ
ります。


●JTAGENヒューズ

　最近発表されたデバイスは JTAG 機能を持っているものが増えています。デフォルト
では JTAG が有効になっていて、JTAG 機能と重複するピンが I/O ポートとして使えま
せん。これを通常の I/O として使えるようにするには、プログラム実行時に MCU 制御
レジスタの JTD ビットを立てる必要があります。または、JTAGEN ヒューズをアンプロ
グラム ("1") します。


●各種パラレルアダプタの自動認識

　avrsp/avrspx(hidspx) は複数のプログラミングアダプタに対応するため、アダプタの
タイプを自動認識しています。次の順にパラレルポートの接続をチェックして、最初に
マッチした組み合わせでアダプタタイプを決定します。

1. D5-ACK        Altera ByteBlasterMV
2. D7-PE         AVRX
3. D6-BUSY-PE    Xilinx JTAG
4. D6-PE         Lattice ISP
5. D0-PE         STK200 dongle

============ EOF ============
